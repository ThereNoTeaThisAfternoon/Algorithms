# *算法(Algorithm)*

### 深度优先搜索(Depth First Search,DFS)

用于**遍历**或**搜索树**或**图**的算法。

​		沿着树深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。

------

### 广度优先搜索(Breadth First Search,BFS)

又译作**宽度优先搜索**，或**横向优先搜索**，是一种**图形搜索算法**。

​		从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。

------

### 双指针(Double Point)

利用两个指针去遍历数组

​		一般来说，遍历数组采用的是单指针（index)去遍历，两个指针一般是在**有序数组**中使用，一个放**首**，一个放**尾**，同时向中间遍历，直到两个指针**相交**，完成遍历，时间复杂度也是O(n)。

------

### 贪心算法(Greedy Algorithm)

贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。

不考虑整体最优的局部最优解。

在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

------

### 动态规划(Dynamic Programming)

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法

大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

```java
//重叠子问题、因为重复计算，所以需要「空间换时间」，记录子问题的最优解；
//最优子结构、规模较大的问题的最优解，由各个子问题的最优解得到；
//无后效、子结果确定不再更改

//自顶向下：即「递归 + 记忆化」
//自底向上：即「递归」，从一个最小的问题开始，逐步得到最终规模问题的解。

//极大极小用动态规划
```

------

### 分治法(Divide And Conquer)

**分而治之**，把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，**原问题的解即子问题的解的合并。**

```java
//child1+child2+...+childn -->> result
```

![image-20200424134852619](C:\Users\Q1305\AppData\Roaming\Typora\typora-user-images\image-20200424134852619.png)

------

### 回溯算法(Backtracking Algorithm)

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种**走不通就退回再走**的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。

**是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。**

类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

```java
//设置现场→递归→恢复现场		回溯一般用于问所有解法是什么
模板：
result = []
void backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

------

### 堆(Heap)

**近似完全二叉树的数组**。树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。

**最大堆（大根堆）**的每一个节点（除了根结点）的值不大于其父节点；	

**最小堆（小根堆）**的每一个节点（除了根结点）的值不小于其父节点。

```java
常见操作：
//HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 O(n)。
//HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 O(log n)。
//HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度 O(log n)。
//HEAPSORT：借由 HEAPFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为 O(n log n)，空间复杂度为 O(1)。
常见应用：
//常见应用是建立优先队列（Priority Queue）
```

------

### 二分查找(Binary Search)

折半查找，数据结构必须有序，可以在数据规模的对数时间复杂度内完成查找。

需要线性表具有随机访问特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。

------

### 枚举法(Enumeration Method)

**暴力法**，逐个考察某类事物所有可能情况，从而得出一般结论。

将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，合适就保留，不合适就丢弃。

```java
1、得到的结果肯定是正确的；
2、可能做了很多的无用功，浪费了宝贵的时间，效率低下。
3、通常会涉及到求极值（如最大，最小，最重等）。
4、数据量大的话，可能会造成时间崩溃。
//思路
    （1）确定枚举对象、枚举范围和判定条件；
	（2）枚举可能的解，验证是否是问题的解。
```

------

### 滑动窗口(Sliding Window)

解决数组/字符串的**子元素**问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。

```java
int left = 0, right = 0;
while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

------

### 位运算

```java
与[&]
或[|]
非[!]
异或[^]
    任何数和 0 做异或运算，结果仍然是原来的数
	任何数和其 自身 做异或运算，结果是 0
	异或运算满足交换律和结合律
```

------

### 拓扑排序(Topological Sort)

对**有向无环图(Directed Acyclic Graph简称DAG)**的拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。

------

### 快慢指针(Fast Slow Pointer)

```java
/*
快慢指针思想, fast 和 slow 是指针, nums[slow] 表示取指针对应的元素
因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素,
即按照寻找链表环入口的思路来处理
```

------

### 蒙特卡罗法

蒙特卡罗法也称**统计模拟法、统计试验法**。是**把概率现象作为研究对象的数值模拟方法**。是按抽样调查法求取统计值来推定未知特性量的计算方法。蒙特卡罗是摩纳哥的著名赌城，该法为表明其随机抽样的本质而命名。故适用于对离散系统进行计算仿真试验。在计算仿真中，通过构造一个和系统性能相近似的概率模型，并在数字计算机上进行随机试验，可以模拟系统的随机特性。

------

# 集合(Collection)

### 数组(Array)

**有限**个**相同类型**的**可重复元素**的**有序集合**，定长。

组成：数组名，元素，元素下标

------

### 字符串(String)

存储上类似字符数组，每一个单个元素可提取

------

### List（Array List，Linked List，Vector，Iterator）

列表、线性存储、元素可重复有序、索引访问

### 数组列表(Array List)

动态数组，随需要而增长

### 链表(Linked List)

**线性表**，但不会按线性顺序存储数据，而是在每一个节点里存到下一个节点的指针（Pointer）。

物理存储单元上**非连续**、**非顺序**的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。

每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

```java
//允许插入和移除表上任意位置上的节点，但是不允许随机存取。
//头插法next->cur 尾插法cur->next
//单向链表，双向链表以及循环链表。
```

### 向量(Vector)



### 迭代器(Iterator)



------

### Set（Hash Set、Tree Set）

### 散列集(Hash Set)



### 树集(Tree Set)



------

### Map(Hash Map、Tree Map、Hash Table)

### 哈希映射(Hash Map)



### 树映射(Tree Map)



### 哈希表(Hash Table)

**散列表**，根据键（Key）而直接访问在内存存储位置的**数据结构**。

通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做**哈希函数**，存放记录的数组称做**哈希表**。

使用 O(1) 时间进行数据的插入删除和查找，但是哈希表中数据无序，这样在哈希表中查找最大数据或者最小数据的时间是 O(N)实现。

------

### 栈(Stack)

**堆栈**，是一种重要的数据结构。是一种操作受限的线性表，限定在表尾（栈顶）进行插入和删除操作，表头（栈顶），基本操作还有栈的初始化，判空，取栈顶元素等。






